{"version":3,"sources":["script.js"],"names":["measures","canvasW","canvasH","gameCurrent","document","gameWordSearch","window","countdownTimer","let","$","trigger","pointMulti","definedWords","setTimeout","WordSearch","wordsBase","word","workAll","each","_this","removerAcentos","completeWord","wordList","puzzleWidth","text","puzzleHeight","game","drawLineAlpha","this","drawLineThickness","highlightTintIndice","index","value","highlightTint","toLowerCase","drawLine","preload","create","activeTime","puzzle","orientations","solution","wordfind","tileWidth","tileHeight","drawLineColor","highlightTintContainer","onInputOver","onInputOut","isSelecting","firstLetter","endLetter","foundWords","forEach","tile","prototype","getChildAt","data","length","path","load","bitmapFont","letters","letter","nameIMG","grid","height","x_InitSolution","x","scaleRatio","devicePixelRatio","scale","scaleMode","Phaser","ScaleManager","SHOW_ALL","setShowAll","addEventListener","refresh","stage","backgroundColor","newPuzzle","words","width","allOrientations","entry","indice","li","textContent","solve","found","console","add","group","inputEnableChildren","row","y","input","addMoveCallback","updateDrawLine","startWord","onInputDown","pointer","startLetterSelect","events","stopLetterSelect","overLetter","outLetter","lineStyle","orientation","gameWon","element","querySelector","listContainer","tint","replace","appendChild","classList","checkLetterAlignment","selection","graphics","startColumn","endRow","clear","column","worldScale","worldPosition","tw","getLetterAt","th","lineTo","getSelectedLetters","selectedWord","right","bottom","last","max","first","result","concat","Math","left","clearLine","push","highlightCorrectWord","countWord","tinta","error","inverse","checkSelectedLetters","setAll","map","sprite","frame","Á","î","_containerTela","startRow","endColumn","abs","top","min","Utils","reverseString","s","â","Â","à","À","á","ê","Ê","è","È","Î","ì","Ì","í","Í","õ","Õ","ô","Ô","ò","Ó","ü","Ü","û","Û","ú","Ú","ù","Ù","a","Game","CANVAS","state","ready"],"mappings":"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","file":"script.js","sourcesContent":["const measures = {\n  canvasW: 920,\n  canvasH: 910,\n};\n\nconst allOrientations = [\n  \"horizontal\",\n  \"horizontalBack\",\n  \"vertical\",\n  \"verticalUp\",\n  \"diagonal\",\n  \"diagonalUp\",\n  \"diagonalBack\",\n  \"diagonalUpBack\",\n];\n\nconst gameCurrent = 3;\nconst timeGame = 60 * 1; ///60\nlet workAll = 0;\nconst pointMulti = 10;\nconst definedWords = [\n  \"Compliance\",\n  \"Crédito\",\n  \"ESG\",\n  \"LGPD\",\n  \"SAC\",\n  \"PLDFT\",\n  \"Libras\",\n  \"Sustentabilidade\",\n  \"Preparatório\",\n  \"Correspondentes\",\n];\n\n$(document).ready(function () {\n  gameWordSearch();\n});\n\nfunction countWord(word) {\n  workAll += word;\n}\n\nfunction activeTime() {\n  window.countdownTimer(timeGame, () => {\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\n  });\n}\n\nfunction completeWord() {\n  setTimeout(function () {\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\n  }, 1000 * 1);\n}\n\nfunction gameWordSearch() {\n  $(\".info .value\").text(\"01:00\");\n  var WordSearch = {};\n\n  WordSearch.Game = function (game) {\n    //  This is your word list. Add or remove any words you like in here.\n    //  The words mustn't contain any spaces or numbers.\n\n    //  The shorter the array, the larger the letter tiles will scale in-game.\n\n    var _this = this;\n    this.words = [];\n    this.wordsBase = definedWords;\n\n    //this.wordsBase = ['Colaboração', 'Proximidade'];\n\n    $.each(this.wordsBase, function (index, value) {\n      _this.words.push(_this.removerAcentos(value).toLowerCase());\n    });\n\n    this.letters = [\n      \"A\",\n      \"B\",\n      \"C\",\n      \"D\",\n      \"E\",\n      \"F\",\n      \"G\",\n      \"H\",\n      \"I\",\n      \"J\",\n      \"K\",\n      \"L\",\n      \"M\",\n      \"N\",\n      \"O\",\n      \"P\",\n      \"Q\",\n      \"R\",\n      \"S\",\n      \"T\",\n      \"U\",\n      \"V\",\n      \"W\",\n      \"X\",\n      \"Y\",\n      \"Z\",\n      \"Ç\",\n      \"Ã\",\n      \"É\",\n      \"Ó\",\n    ];\n\n    this.puzzle = null;\n    this.solution = null;\n\n    //  The BitmapFont word list down the side\n    this.wordList = {};\n\n    //  The dimensions of the word search, in letters (not pixels)\n    //  You can set a fixed size here.\n    //  Or set to -1 means it'll adapt to fit the longest word in the words array.\n    this.puzzleWidth = -1;\n    this.puzzleHeight = -1;\n\n    //  The size of each letter sprite sheet, in pixels\n    this.tileWidth = 100;\n    this.tileHeight = 100;\n\n    //  The selection line color and thickness\n    this.drawLineColor = 0x00ff00;\n    this.drawLineAlpha = 0.6;\n    this.drawLineThickness = 26;\n\n    //  A tint applied to the letters when a word is found\n    // this.highlightTintContainer = [\"#E90F6A\", \"#0bb7e1\", \"#D9F339\"];\n    this.highlightTintContainer = [\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n    ];\n    this.highlightTintIndice = 0;\n    this.highlightTint = 0xffff00;\n\n    //  Booleans to control the game during play\n    this.drawLine = null;\n\n    this.isSelecting = false;\n    this.firstLetter = null;\n    this.endLetter = null;\n    this.foundWords = [];\n  };\n\n  WordSearch.Game.prototype = {\n    preload: function () {\n      //this.load.script('wordfind', 'libs/wordfind.js');\n\n      this.load.path = \"../../assets/img/game3/\";\n\n      this.load.bitmapFont(\"azo\");\n\n      var _this = this;\n\n      this.letters.forEach(function (letter) {\n        var nameIMG = letter;\n\n        if (letter == \"Ã\") nameIMG = \"A1\";\n        else if (letter == \"Ç\") nameIMG = \"C1\";\n        else if (letter == \"É\") nameIMG = \"E1\";\n        else if (letter == \"Ó\") nameIMG = \"O1\";\n\n        _this.load.spritesheet(\n          letter.toLowerCase(),\n          nameIMG + \".png\",\n          _this.tileWidth,\n          _this.tileHeight\n        );\n      });\n\n      this.scaleRatio = window.devicePixelRatio / 3;\n\n      _this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n      _this.scale.setShowAll();\n\n      window.addEventListener(\"resize\", function () {\n        _this.scale.refresh();\n      });\n      _this.scale.refresh();\n    },\n\n    create: function () {\n      this.stage.backgroundColor = \"#ffffff\";\n\n      activeTime();\n\n      if (this.puzzleWidth !== -1) {\n        this.puzzle = wordfind.newPuzzle(this.words, {\n          width: this.puzzleWidth,\n          height: this.puzzleHeight,\n          orientations: allOrientations,\n        });\n      } else {\n        this.puzzle = wordfind.newPuzzle(this.words, {\n          orientations: allOrientations,\n        });\n        this.puzzleWidth = this.puzzle[0].length;\n        this.puzzleHeight = this.puzzle.length;\n      }\n\n      var solution = wordfind.solve(this.puzzle, this.words);\n\n      this.solution = solution.found;\n\n      //  Un-comment these to Debug the puzzle, the first outputs the puzzle to the console\n      //  The second outputs the answers object\n\n      // wordfind.print(this.puzzle);\n      // console.log(this.solution);\n\n      //  Create the letter tile grid\n\n      var x = 0;\n      var y = 0;\n      var _this = this;\n\n      this.grid = this.add.group();\n      this.grid.inputEnableChildren = true;\n\n      this.puzzle.forEach(function (row) {\n        row.forEach(function (letter) {\n          var tile = _this.grid.create(x, y, letter, 0);\n\n          tile.data.row = x / _this.tileWidth;\n          tile.data.column = y / _this.tileHeight;\n          tile.data.words = {};\n          tile.data.letter = letter;\n          tile.data.startWord = false;\n\n          tile.events.onInputDown.add(_this.startLetterSelect, _this);\n          tile.events.onInputUp.add(_this.stopLetterSelect, _this);\n          tile.events.onInputOver.add(_this.overLetter, _this);\n          tile.events.onInputOut.add(_this.outLetter, _this);\n\n          x += _this.tileWidth;\n        });\n\n        x = 0;\n        y += _this.tileHeight;\n      });\n\n      //  Flag all of the starting letters in the grid\n      this.solution.forEach(function (entry) {\n        //  Based on the grid position we can get the tile index\n        var index = entry.y * _this.puzzleWidth + entry.x;\n\n        var tile = _this.grid.getChildAt(index);\n\n        tile.data.startWord = true;\n        tile.data.words[entry.word] = {\n          orientation: entry.orientation,\n          length: entry.word.length,\n        };\n      });\n\n      //  This controls the position and scale of the word search grid\n      //  Setting the width / height automatically scales the Group\n      //  If you remove this, the tiles will be displayed at their full size\n      //\n      //  Use it to position the grid within your game, and make sure it fits\n      //  no matter how many words are in it.\n\n      this.grid.x = 45;\n      this.grid.y = 45;\n      this.grid.width = 827;\n      this.grid.height = 816;\n\n      //  Display the words to find down the right-hand side, and add to the wordList object\n\n      var x_InitSolution = 40;\n      var y_InitSolution = 880;\n\n      x = x_InitSolution;\n      y = y_InitSolution;\n\n      // Palavras dicas\n      // this.solution.forEach(function (entry, indice) {\n      //   //  One BitmapText per word (so we can change their color when found)\n      //   var style = {\n      //     font: \"30px Arial\", ///Import: Usar sempre Arial para nao quebrar a font\n      //     fill: \"0x000000\",\n      //     align: \"left\",\n      //   };\n\n      //   x = indice < 5 ? x : x_SecondCol; /// Da quinta palavra já cria a segunda coluna\n      //   y = indice == 5 ? y_InitSolution : y;\n\n      //   var _palavras = _this.add.text(x, y, _this.wordsBase[indice], style);\n      //   _palavras.fontWeight = \"bold\";\n\n      //   _this.wordList[entry.word] = _palavras;\n\n      //   y += 42;\n      // });\n\n      // Verifique se a lista de palavras existe no DOM\n      const listContainer = document.querySelector(\"ul.listPalavras\");\n\n      // Se a lista de palavras existir no DOM\n      if (listContainer) {\n        // Iterar sobre cada entrada na solução\n        this.solution.forEach((entry, indice) => {\n          // Criar um elemento <li> para representar a palavra\n          const li = document.createElement(\"li\");\n          li.textContent = this.wordsBase[indice];\n\n          // Adicionar o elemento <li> à lista de palavras\n          listContainer.appendChild(li);\n\n          // Armazenar uma referência ao elemento de texto criado para a palavra correspondente\n          this.wordList[entry.word] = li;\n\n          // Adicionar uma classe CSS para estilizar a palavra\n          li.classList.add(\"word\");\n        });\n      } else {\n        // Se a lista de palavras não existir no DOM, exibir um erro no console\n        console.error(\n          \"A lista de palavras (ul.listPalavras) não foi encontrada no DOM.\"\n        );\n      }\n\n      //  The Graphics object that controls the letter selection line\n\n      this.drawLine = this.add.graphics(0, 0);\n\n      //  This starts a callback going, that updates whenever the mouse moves,\n      //  and calls updateDrawLine. All of the main game logic happens as a result\n      //  of events triggered within here, and the letter tile input handlers.\n\n      this.input.addMoveCallback(this.updateDrawLine, this);\n    },\n\n    /**\n     * Draws the selection line, showing which letter tiles are being selected.\n     */\n    updateDrawLine: function (pointer, x, y) {\n      if (!this.isSelecting) {\n        return;\n      }\n\n      this.drawLine.clear();\n\n      this.drawLine.lineStyle(\n        this.drawLineThickness,\n        this.drawLineColor,\n        this.drawLineAlpha\n      );\n\n      var tw = (this.tileWidth * this.firstLetter.worldScale.x) / 2;\n      var th = (this.tileHeight * this.firstLetter.worldScale.y) / 2;\n\n      this.drawLine.moveTo(\n        this.firstLetter.worldPosition.x + tw,\n        this.firstLetter.worldPosition.y + th\n      );\n\n      this.drawLine.lineTo(x, y);\n    },\n\n    /**\n     * Called when the mouse is pressed down on any of the letter tiles.\n     */\n    startLetterSelect: function (letter) {\n      this.isSelecting = true;\n\n      this.firstLetter = letter;\n    },\n\n    /**\n     * Called when the mouse is released from any of the letter tiles.\n     * This performs all of the core checks in terms of if they've selected\n     * a full word, won the game, etc.\n     */\n    stopLetterSelect: function (letter) {\n      this.isSelecting = false;\n\n      //  Let's check to see if they selected an actual word :)\n      if (\n        this.firstLetter &&\n        this.endLetter &&\n        this.firstLetter !== this.endLetter &&\n        (this.firstLetter.data.startWord || this.endLetter.data.startWord) &&\n        this.checkLetterAlignment(this.endLetter)\n      ) {\n        var result = this.checkSelectedLetters();\n\n        if (result) {\n          this.highlightCorrectWord(result);\n          this.foundWords.push(result.word);\n        }\n\n        //  Check word list, game won?\n        if (this.foundWords.length === this.solution.length) {\n          this.gameWon();\n        }\n      }\n\n      this.grid.setAll(\"frame\", 0);\n\n      this.clearLine();\n    },\n\n    /**\n     * Clears the selection line, and resets the first and last letters.\n     */\n    clearLine: function () {\n      this.firstLetter = false;\n      this.endLetter = null;\n\n      this.drawLine.clear();\n    },\n\n    /**\n     * Called from within stopLetterSelect and both tints the BitmapText word\n     * on the right-hand side, and also tints each tile that was matched.\n     *\n     * If you're going to use a different kind of effect, then you probably want\n     * to edit or skip most of this function.\n     */\n    highlightCorrectWord: function (result) {\n      var _this = this;\n\n      countWord(1);\n\n      //  result contains the sprites of the letters, the word, etc.\n      var tinta = this.highlightTintContainer[this.highlightTintIndice];\n      this.wordList[result.word].fill = tinta;\n\n      var element = this.wordList[result.word];\n\n      // Verifica se o elemento foi encontrado\n      if (element) {\n        // Adiciona a classe 'visited' ao elemento\n        element.classList.add(\"visited\");\n      } else {\n        console.error(\n          \"Elemento não encontrado para a palavra-chave:\",\n          result.word\n        );\n      }\n\n      result.letters.forEach(function (letter) {\n        letter.tint = tinta.replace(\"#\", \"0x\");\n      });\n\n      this.highlightTintIndice += 1;\n    },\n\n    /**\n     * Called by the letter tile input handler when it is moused over.\n     * In short, it checks if it should swap frame or not.\n     */\n    overLetter: function (letter) {\n      if (this.isSelecting) {\n        if (this.checkLetterAlignment(letter)) {\n          this.endLetter = letter;\n\n          //  Highlight the tiles below the line (if any)\n          var selection = this.getSelectedLetters();\n\n          if (selection && selection.letters.length > 0) {\n            this.grid.setAll(\"frame\", 0);\n\n            selection.letters.forEach(function (sprite) {\n              sprite.frame = 1;\n            });\n          }\n        }\n      } else {\n        letter.frame = 1;\n      }\n    },\n\n    /**\n     * Swaps the letter frame back, if not in selecting mode.\n     */\n    outLetter: function (letter) {\n      if (!this.isSelecting) {\n        letter.frame = 0;\n      }\n    },\n\n    /**\n     * Called once all words have been found.\n     */\n    gameWon: function (_containerTela) {\n      completeWord();\n    },\n\n    //  From this point on, all of the functions deal with checking the letters,\n    //  getting selected letters, and checking for word matching. There is no\n    //  display related code in any of the following, it's all game logic.\n\n    checkLetterAlignment: function (letter) {\n      var startRow = this.firstLetter.data.row;\n      var startColumn = this.firstLetter.data.column;\n      var endRow = letter.data.row;\n      var endColumn = letter.data.column;\n\n      return (\n        startColumn === endColumn ||\n        startRow === endRow ||\n        Math.abs(endColumn - startColumn) === Math.abs(endRow - startRow)\n      );\n    },\n\n    getLetterAt: function (row, column) {\n      var index = column * this.puzzleWidth + row;\n\n      return this.grid.getChildAt(index);\n    },\n\n    getSelectedLetters: function () {\n      if (\n        !this.firstLetter ||\n        !this.endLetter ||\n        this.endLetter === this.firstLetter\n      ) {\n        return false;\n      }\n\n      var first = this.firstLetter.data;\n      var last = this.endLetter.data;\n      var tile;\n      var letters = [];\n      var selectedWord = \"\";\n      var x, y, top, bottom, left, right;\n\n      //  Let's get all the letters between the first and end letters\n\n      if (first.row === last.row) {\n        //  Vertical grab\n\n        top = Math.min(first.column, last.column);\n        bottom = Math.max(first.column, last.column);\n\n        for (y = top; y <= bottom; y++) {\n          tile = this.getLetterAt(first.row, y);\n          letters.push(tile);\n          selectedWord = selectedWord.concat(tile.data.letter);\n        }\n      } else if (first.column === last.column) {\n        //  Horizontal grab\n\n        left = Math.min(first.row, last.row);\n        right = Math.max(first.row, last.row);\n\n        for (x = left; x <= right; x++) {\n          tile = this.getLetterAt(x, first.column);\n          letters.push(tile);\n          selectedWord = selectedWord.concat(tile.data.letter);\n        }\n      } else {\n        top = Math.min(first.column, last.column);\n        bottom = Math.max(first.column, last.column);\n        left = Math.min(first.row, last.row);\n        right = Math.max(first.row, last.row);\n\n        if (first.column > last.column && first.row < last.row) {\n          //  Diagonal NE grab (up and from left to right)\n          y = bottom;\n\n          for (x = left; x <= right; x++) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y--;\n          }\n        } else if (first.column < last.column && first.row < last.row) {\n          //  Diagonal SE grab (down and from left to right)\n          y = top;\n\n          for (x = left; x <= right; x++) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y++;\n          }\n        } else if (first.column < last.column && first.row > last.row) {\n          //  Diagonal SW grab (down and from right to left)\n          y = top;\n\n          for (x = right; x >= left; x--) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y++;\n          }\n        } else if (first.column > last.column && first.row > last.row) {\n          //  Diagonal NW grab (up and from right to left)\n          y = bottom;\n\n          for (x = right; x >= left; x--) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y--;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return {\n        word: selectedWord,\n        inverse: Phaser.Utils.reverseString(selectedWord),\n        letters: letters,\n      };\n    },\n\n    checkSelectedLetters: function () {\n      var selection = this.getSelectedLetters();\n\n      if (selection) {\n        //  It's possible that a single letter could start multiple words in different directions:\n        //\n        //  cow..\n        //  a....\n        //  r....\n\n        var starter = this.firstLetter.data.startWord\n          ? this.firstLetter.data\n          : this.endLetter.data;\n\n        for (var word in starter.words) {\n          if (word === selection.word || word === selection.inverse) {\n            return {\n              word: word,\n              letters: selection.letters,\n            };\n          }\n        }\n      }\n\n      return false;\n    },\n\n    removerAcentos: function (s) {\n      var map = {\n        â: \"a\",\n        Â: \"A\",\n        à: \"a\",\n        À: \"A\",\n        á: \"a\",\n        Á: \"A\",\n        /*\"ã\": \"a\",\n        \"Ã\": \"A\",*/\n        ê: \"e\",\n        Ê: \"E\",\n        è: \"e\",\n        È: \"E\",\n        // é: \"e\",\n        // É: \"E\",\n        î: \"i\",\n        Î: \"I\",\n        ì: \"i\",\n        Ì: \"I\",\n        í: \"i\",\n        Í: \"I\",\n        õ: \"o\",\n        Õ: \"O\",\n        ô: \"o\",\n        Ô: \"O\",\n        ò: \"o\",\n        // Ò: \"O\",\n        // ó: \"o\",\n        Ó: \"O\",\n        ü: \"u\",\n        Ü: \"U\",\n        û: \"u\",\n        Û: \"U\",\n        ú: \"u\",\n        Ú: \"U\",\n        ù: \"u\",\n        Ù: \"U\",\n        /*\"ç\": \"c\",\n        \"Ç\": \"C\"*/\n      };\n\n      return s.replace(/[\\W\\[\\] ]/g, function (a) {\n        return map[a] || a;\n      });\n    },\n  };\n\n  //  Creates the game instance and starts it running\n\n  var game = new Phaser.Game(\n    measures.canvasW,\n    measures.canvasH,\n    Phaser.CANVAS,\n    \"game\"\n  );\n  game.state.add(\"WordSearch.Game\", WordSearch.Game, true);\n}\n"]}