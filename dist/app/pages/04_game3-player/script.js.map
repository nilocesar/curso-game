{"version":3,"sources":["script.js"],"names":["measures","canvasW","canvasH","allOrientations","pointMulti","definedWords","$","document","ready","gameWordSearch","countWord","trigger","workAll","word","setTimeout","window","countdownTimer","timeGame","gameCurrent","WordSearch","Game","text","game","_this","this","puzzle","solution","each","wordsBase","index","value","words","push","removerAcentos","toLowerCase","puzzleWidth","preload","nameIMG","wordList","scaleRatio","refresh","tileWidth","backgroundColor","activeTime","drawLineColor","drawLineAlpha","puzzleHeight","drawLineThickness","highlightTintContainer","highlightTintIndice","highlightTint","drawLine","isSelecting","firstLetter","add","endLetter","inputEnableChildren","foundWords","forEach","tile","data","startWord","events","onInputUp","letters","letter","x","entry","spritesheet","orientation","devicePixelRatio","scale","scaleMode","Phaser","ScaleManager","SHOW_ALL","setShowAll","addEventListener","grid","create","stage","y_InitSolution","x_InitSolution","newPuzzle","height","orientations","wordfind","length","solve","found","y","listContainer","li","textContent","row","column","tileHeight","onInputDown","startLetterSelect","stopLetterSelect","onInputOver","overLetter","console","onInputOut","outLetter","getChildAt","updateDrawLine","pointer","querySelector","indice","createElement","appendChild","tinta","classList","element","graphics","addMoveCallback","selection","getSelectedLetters","tw","th","clear","lineStyle","worldScale","worldPosition","lineTo","checkLetterAlignment","selectedWord","first","checkSelectedLetters","highlightCorrectWord","result","Math","last","bottom","gameWon","max","clearLine","left","right","error","tint","replace","getLetterAt","setAll","sprite","frame","starter","_containerTela","completeWord","startRow","startColumn","endRow","endColumn","Ì","í","Í","abs","Û","ú","Ú","Ù","top","min","concat","inverse","Utils","reverseString","s","map","â","Â","à","À","á","Á","ê","Ê","è","È","î","Î","ì","õ","Õ","ô","Ô","ò","Ó","ü","Ü","û","ù","a","CANVAS","state"],"mappings":"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","file":"script.js","sourcesContent":["const measures = {\n  canvasW: 920,\n  canvasH: 910,\n};\n\nconst allOrientations = [\n  \"horizontal\",\n  // \"horizontalBack\",\n  \"vertical\",\n  // \"verticalUp\",\n  \"diagonal\",\n  // \"diagonalUp\",\n  // \"diagonalBack\",\n  // \"diagonalUpBack\",\n];\n\nconst gameCurrent = 3;\nconst timeGame = 60 * 1; ///60\nlet workAll = 0;\nconst pointMulti = 10;\nconst definedWords = [\"latim\", \"manuscrito\", \"layout\", \"template\"];\n\n$(document).ready(function () {\n  gameWordSearch();\n});\n\nfunction countWord(word) {\n  workAll += word;\n}\n\nfunction activeTime() {\n  window.countdownTimer(timeGame, () => {\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\n  });\n}\n\nfunction completeWord() {\n  setTimeout(function () {\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\n  }, 1000 * 1);\n}\n\nfunction gameWordSearch() {\n  $(\".info .value\").text(\"01:00\");\n  var WordSearch = {};\n\n  WordSearch.Game = function (game) {\n    //  This is your word list. Add or remove any words you like in here.\n    //  The words mustn't contain any spaces or numbers.\n\n    //  The shorter the array, the larger the letter tiles will scale in-game.\n\n    var _this = this;\n    this.words = [];\n    this.wordsBase = definedWords;\n\n    //this.wordsBase = ['Colaboração', 'Proximidade'];\n\n    $.each(this.wordsBase, function (index, value) {\n      _this.words.push(_this.removerAcentos(value).toLowerCase());\n    });\n\n    this.letters = [\n      \"A\",\n      \"B\",\n      \"C\",\n      \"D\",\n      \"E\",\n      \"F\",\n      \"G\",\n      \"H\",\n      \"I\",\n      \"J\",\n      \"K\",\n      \"L\",\n      \"M\",\n      \"N\",\n      \"O\",\n      \"P\",\n      \"Q\",\n      \"R\",\n      \"S\",\n      \"T\",\n      \"U\",\n      \"V\",\n      \"W\",\n      \"X\",\n      \"Y\",\n      \"Z\",\n      \"Ç\",\n      \"Ã\",\n      \"É\",\n      \"Ó\",\n    ];\n\n    this.puzzle = null;\n    this.solution = null;\n\n    //  The BitmapFont word list down the side\n    this.wordList = {};\n\n    //  The dimensions of the word search, in letters (not pixels)\n    //  You can set a fixed size here.\n    //  Or set to -1 means it'll adapt to fit the longest word in the words array.\n    this.puzzleWidth = -1;\n    this.puzzleHeight = -1;\n\n    //  The size of each letter sprite sheet, in pixels\n    this.tileWidth = 100;\n    this.tileHeight = 100;\n\n    //  The selection line color and thickness\n    this.drawLineColor = 0x00ff00;\n    this.drawLineAlpha = 0.6;\n    this.drawLineThickness = 26;\n\n    //  A tint applied to the letters when a word is found\n    // this.highlightTintContainer = [\"#E90F6A\", \"#0bb7e1\", \"#D9F339\"];\n    this.highlightTintContainer = [\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n      \"#D9F339\",\n    ];\n    this.highlightTintIndice = 0;\n    this.highlightTint = 0xffff00;\n\n    //  Booleans to control the game during play\n    this.drawLine = null;\n\n    this.isSelecting = false;\n    this.firstLetter = null;\n    this.endLetter = null;\n    this.foundWords = [];\n  };\n\n  WordSearch.Game.prototype = {\n    preload: function () {\n      //this.load.script('wordfind', 'libs/wordfind.js');\n\n      this.load.path = \"../../assets/img/game3/\";\n\n      this.load.bitmapFont(\"azo\");\n\n      var _this = this;\n\n      this.letters.forEach(function (letter) {\n        var nameIMG = letter;\n\n        if (letter == \"Ã\") nameIMG = \"A1\";\n        else if (letter == \"Ç\") nameIMG = \"C1\";\n        else if (letter == \"É\") nameIMG = \"E1\";\n        else if (letter == \"Ó\") nameIMG = \"O1\";\n\n        _this.load.spritesheet(\n          letter.toLowerCase(),\n          nameIMG + \".png\",\n          _this.tileWidth,\n          _this.tileHeight\n        );\n      });\n\n      this.scaleRatio = window.devicePixelRatio / 3;\n\n      _this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n      _this.scale.setShowAll();\n\n      window.addEventListener(\"resize\", function () {\n        _this.scale.refresh();\n      });\n      _this.scale.refresh();\n    },\n\n    create: function () {\n      this.stage.backgroundColor = \"#ffffff\";\n\n      activeTime();\n\n      if (this.puzzleWidth !== -1) {\n        this.puzzle = wordfind.newPuzzle(this.words, {\n          width: this.puzzleWidth,\n          height: this.puzzleHeight,\n          orientations: allOrientations,\n        });\n      } else {\n        this.puzzle = wordfind.newPuzzle(this.words, {\n          orientations: allOrientations,\n        });\n        this.puzzleWidth = this.puzzle[0].length;\n        this.puzzleHeight = this.puzzle.length;\n      }\n\n      var solution = wordfind.solve(this.puzzle, this.words);\n\n      this.solution = solution.found;\n\n      //  Un-comment these to Debug the puzzle, the first outputs the puzzle to the console\n      //  The second outputs the answers object\n\n      // wordfind.print(this.puzzle);\n      // console.log(this.solution);\n\n      //  Create the letter tile grid\n\n      var x = 0;\n      var y = 0;\n      var _this = this;\n\n      this.grid = this.add.group();\n      this.grid.inputEnableChildren = true;\n\n      this.puzzle.forEach(function (row) {\n        row.forEach(function (letter) {\n          var tile = _this.grid.create(x, y, letter, 0);\n\n          tile.data.row = x / _this.tileWidth;\n          tile.data.column = y / _this.tileHeight;\n          tile.data.words = {};\n          tile.data.letter = letter;\n          tile.data.startWord = false;\n\n          tile.events.onInputDown.add(_this.startLetterSelect, _this);\n          tile.events.onInputUp.add(_this.stopLetterSelect, _this);\n          tile.events.onInputOver.add(_this.overLetter, _this);\n          tile.events.onInputOut.add(_this.outLetter, _this);\n\n          x += _this.tileWidth;\n        });\n\n        x = 0;\n        y += _this.tileHeight;\n      });\n\n      //  Flag all of the starting letters in the grid\n      this.solution.forEach(function (entry) {\n        //  Based on the grid position we can get the tile index\n        var index = entry.y * _this.puzzleWidth + entry.x;\n\n        var tile = _this.grid.getChildAt(index);\n\n        tile.data.startWord = true;\n        tile.data.words[entry.word] = {\n          orientation: entry.orientation,\n          length: entry.word.length,\n        };\n      });\n\n      //  This controls the position and scale of the word search grid\n      //  Setting the width / height automatically scales the Group\n      //  If you remove this, the tiles will be displayed at their full size\n      //\n      //  Use it to position the grid within your game, and make sure it fits\n      //  no matter how many words are in it.\n\n      this.grid.x = 45;\n      this.grid.y = 45;\n      this.grid.width = 827;\n      this.grid.height = 816;\n\n      //  Display the words to find down the right-hand side, and add to the wordList object\n\n      var x_InitSolution = 40;\n      var y_InitSolution = 880;\n\n      x = x_InitSolution;\n      y = y_InitSolution;\n\n      // Palavras dicas\n      // this.solution.forEach(function (entry, indice) {\n      //   //  One BitmapText per word (so we can change their color when found)\n      //   var style = {\n      //     font: \"30px Arial\", ///Import: Usar sempre Arial para nao quebrar a font\n      //     fill: \"0x000000\",\n      //     align: \"left\",\n      //   };\n\n      //   x = indice < 5 ? x : x_SecondCol; /// Da quinta palavra já cria a segunda coluna\n      //   y = indice == 5 ? y_InitSolution : y;\n\n      //   var _palavras = _this.add.text(x, y, _this.wordsBase[indice], style);\n      //   _palavras.fontWeight = \"bold\";\n\n      //   _this.wordList[entry.word] = _palavras;\n\n      //   y += 42;\n      // });\n\n      // Verifique se a lista de palavras existe no DOM\n      const listContainer = document.querySelector(\"ul.listPalavras\");\n\n      // Se a lista de palavras existir no DOM\n      if (listContainer) {\n        // Iterar sobre cada entrada na solução\n        this.solution.forEach((entry, indice) => {\n          // Criar um elemento <li> para representar a palavra\n          const li = document.createElement(\"li\");\n          li.textContent = this.wordsBase[indice];\n\n          // Adicionar o elemento <li> à lista de palavras\n          listContainer.appendChild(li);\n\n          // Armazenar uma referência ao elemento de texto criado para a palavra correspondente\n          this.wordList[entry.word] = li;\n\n          // Adicionar uma classe CSS para estilizar a palavra\n          li.classList.add(\"word\");\n        });\n      } else {\n        // Se a lista de palavras não existir no DOM, exibir um erro no console\n        console.error(\n          \"A lista de palavras (ul.listPalavras) não foi encontrada no DOM.\"\n        );\n      }\n\n      //  The Graphics object that controls the letter selection line\n\n      this.drawLine = this.add.graphics(0, 0);\n\n      //  This starts a callback going, that updates whenever the mouse moves,\n      //  and calls updateDrawLine. All of the main game logic happens as a result\n      //  of events triggered within here, and the letter tile input handlers.\n\n      this.input.addMoveCallback(this.updateDrawLine, this);\n    },\n\n    /**\n     * Draws the selection line, showing which letter tiles are being selected.\n     */\n    updateDrawLine: function (pointer, x, y) {\n      if (!this.isSelecting) {\n        return;\n      }\n\n      this.drawLine.clear();\n\n      this.drawLine.lineStyle(\n        this.drawLineThickness,\n        this.drawLineColor,\n        this.drawLineAlpha\n      );\n\n      var tw = (this.tileWidth * this.firstLetter.worldScale.x) / 2;\n      var th = (this.tileHeight * this.firstLetter.worldScale.y) / 2;\n\n      this.drawLine.moveTo(\n        this.firstLetter.worldPosition.x + tw,\n        this.firstLetter.worldPosition.y + th\n      );\n\n      this.drawLine.lineTo(x, y);\n    },\n\n    /**\n     * Called when the mouse is pressed down on any of the letter tiles.\n     */\n    startLetterSelect: function (letter) {\n      this.isSelecting = true;\n\n      this.firstLetter = letter;\n    },\n\n    /**\n     * Called when the mouse is released from any of the letter tiles.\n     * This performs all of the core checks in terms of if they've selected\n     * a full word, won the game, etc.\n     */\n    stopLetterSelect: function (letter) {\n      this.isSelecting = false;\n\n      //  Let's check to see if they selected an actual word :)\n      if (\n        this.firstLetter &&\n        this.endLetter &&\n        this.firstLetter !== this.endLetter &&\n        (this.firstLetter.data.startWord || this.endLetter.data.startWord) &&\n        this.checkLetterAlignment(this.endLetter)\n      ) {\n        var result = this.checkSelectedLetters();\n\n        if (result) {\n          this.highlightCorrectWord(result);\n          this.foundWords.push(result.word);\n        }\n\n        //  Check word list, game won?\n        if (this.foundWords.length === this.solution.length) {\n          this.gameWon();\n        }\n      }\n\n      this.grid.setAll(\"frame\", 0);\n\n      this.clearLine();\n    },\n\n    /**\n     * Clears the selection line, and resets the first and last letters.\n     */\n    clearLine: function () {\n      this.firstLetter = false;\n      this.endLetter = null;\n\n      this.drawLine.clear();\n    },\n\n    /**\n     * Called from within stopLetterSelect and both tints the BitmapText word\n     * on the right-hand side, and also tints each tile that was matched.\n     *\n     * If you're going to use a different kind of effect, then you probably want\n     * to edit or skip most of this function.\n     */\n    highlightCorrectWord: function (result) {\n      var _this = this;\n\n      countWord(1);\n\n      //  result contains the sprites of the letters, the word, etc.\n      var tinta = this.highlightTintContainer[this.highlightTintIndice];\n      this.wordList[result.word].fill = tinta;\n\n      var element = this.wordList[result.word];\n\n      // Verifica se o elemento foi encontrado\n      if (element) {\n        // Adiciona a classe 'visited' ao elemento\n        element.classList.add(\"visited\");\n      } else {\n        console.error(\n          \"Elemento não encontrado para a palavra-chave:\",\n          result.word\n        );\n      }\n\n      result.letters.forEach(function (letter) {\n        letter.tint = tinta.replace(\"#\", \"0x\");\n      });\n\n      this.highlightTintIndice += 1;\n    },\n\n    /**\n     * Called by the letter tile input handler when it is moused over.\n     * In short, it checks if it should swap frame or not.\n     */\n    overLetter: function (letter) {\n      if (this.isSelecting) {\n        if (this.checkLetterAlignment(letter)) {\n          this.endLetter = letter;\n\n          //  Highlight the tiles below the line (if any)\n          var selection = this.getSelectedLetters();\n\n          if (selection && selection.letters.length > 0) {\n            this.grid.setAll(\"frame\", 0);\n\n            selection.letters.forEach(function (sprite) {\n              sprite.frame = 1;\n            });\n          }\n        }\n      } else {\n        letter.frame = 1;\n      }\n    },\n\n    /**\n     * Swaps the letter frame back, if not in selecting mode.\n     */\n    outLetter: function (letter) {\n      if (!this.isSelecting) {\n        letter.frame = 0;\n      }\n    },\n\n    /**\n     * Called once all words have been found.\n     */\n    gameWon: function (_containerTela) {\n      completeWord();\n    },\n\n    //  From this point on, all of the functions deal with checking the letters,\n    //  getting selected letters, and checking for word matching. There is no\n    //  display related code in any of the following, it's all game logic.\n\n    checkLetterAlignment: function (letter) {\n      var startRow = this.firstLetter.data.row;\n      var startColumn = this.firstLetter.data.column;\n      var endRow = letter.data.row;\n      var endColumn = letter.data.column;\n\n      return (\n        startColumn === endColumn ||\n        startRow === endRow ||\n        Math.abs(endColumn - startColumn) === Math.abs(endRow - startRow)\n      );\n    },\n\n    getLetterAt: function (row, column) {\n      var index = column * this.puzzleWidth + row;\n\n      return this.grid.getChildAt(index);\n    },\n\n    getSelectedLetters: function () {\n      if (\n        !this.firstLetter ||\n        !this.endLetter ||\n        this.endLetter === this.firstLetter\n      ) {\n        return false;\n      }\n\n      var first = this.firstLetter.data;\n      var last = this.endLetter.data;\n      var tile;\n      var letters = [];\n      var selectedWord = \"\";\n      var x, y, top, bottom, left, right;\n\n      //  Let's get all the letters between the first and end letters\n\n      if (first.row === last.row) {\n        //  Vertical grab\n\n        top = Math.min(first.column, last.column);\n        bottom = Math.max(first.column, last.column);\n\n        for (y = top; y <= bottom; y++) {\n          tile = this.getLetterAt(first.row, y);\n          letters.push(tile);\n          selectedWord = selectedWord.concat(tile.data.letter);\n        }\n      } else if (first.column === last.column) {\n        //  Horizontal grab\n\n        left = Math.min(first.row, last.row);\n        right = Math.max(first.row, last.row);\n\n        for (x = left; x <= right; x++) {\n          tile = this.getLetterAt(x, first.column);\n          letters.push(tile);\n          selectedWord = selectedWord.concat(tile.data.letter);\n        }\n      } else {\n        top = Math.min(first.column, last.column);\n        bottom = Math.max(first.column, last.column);\n        left = Math.min(first.row, last.row);\n        right = Math.max(first.row, last.row);\n\n        if (first.column > last.column && first.row < last.row) {\n          //  Diagonal NE grab (up and from left to right)\n          y = bottom;\n\n          for (x = left; x <= right; x++) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y--;\n          }\n        } else if (first.column < last.column && first.row < last.row) {\n          //  Diagonal SE grab (down and from left to right)\n          y = top;\n\n          for (x = left; x <= right; x++) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y++;\n          }\n        } else if (first.column < last.column && first.row > last.row) {\n          //  Diagonal SW grab (down and from right to left)\n          y = top;\n\n          for (x = right; x >= left; x--) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y++;\n          }\n        } else if (first.column > last.column && first.row > last.row) {\n          //  Diagonal NW grab (up and from right to left)\n          y = bottom;\n\n          for (x = right; x >= left; x--) {\n            tile = this.getLetterAt(x, y);\n            letters.push(tile);\n            selectedWord = selectedWord.concat(tile.data.letter);\n            y--;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      return {\n        word: selectedWord,\n        inverse: Phaser.Utils.reverseString(selectedWord),\n        letters: letters,\n      };\n    },\n\n    checkSelectedLetters: function () {\n      var selection = this.getSelectedLetters();\n\n      if (selection) {\n        //  It's possible that a single letter could start multiple words in different directions:\n        //\n        //  cow..\n        //  a....\n        //  r....\n\n        var starter = this.firstLetter.data.startWord\n          ? this.firstLetter.data\n          : this.endLetter.data;\n\n        for (var word in starter.words) {\n          if (word === selection.word || word === selection.inverse) {\n            return {\n              word: word,\n              letters: selection.letters,\n            };\n          }\n        }\n      }\n\n      return false;\n    },\n\n    removerAcentos: function (s) {\n      var map = {\n        â: \"a\",\n        Â: \"A\",\n        à: \"a\",\n        À: \"A\",\n        á: \"a\",\n        Á: \"A\",\n        /*\"ã\": \"a\",\n        \"Ã\": \"A\",*/\n        ê: \"e\",\n        Ê: \"E\",\n        è: \"e\",\n        È: \"E\",\n        // é: \"e\",\n        // É: \"E\",\n        î: \"i\",\n        Î: \"I\",\n        ì: \"i\",\n        Ì: \"I\",\n        í: \"i\",\n        Í: \"I\",\n        õ: \"o\",\n        Õ: \"O\",\n        ô: \"o\",\n        Ô: \"O\",\n        ò: \"o\",\n        // Ò: \"O\",\n        // ó: \"o\",\n        Ó: \"O\",\n        ü: \"u\",\n        Ü: \"U\",\n        û: \"u\",\n        Û: \"U\",\n        ú: \"u\",\n        Ú: \"U\",\n        ù: \"u\",\n        Ù: \"U\",\n        /*\"ç\": \"c\",\n        \"Ç\": \"C\"*/\n      };\n\n      return s.replace(/[\\W\\[\\] ]/g, function (a) {\n        return map[a] || a;\n      });\n    },\n  };\n\n  //  Creates the game instance and starts it running\n\n  var game = new Phaser.Game(\n    measures.canvasW,\n    measures.canvasH,\n    Phaser.CANVAS,\n    \"game\"\n  );\n  game.state.add(\"WordSearch.Game\", WordSearch.Game, true);\n}\n"]}