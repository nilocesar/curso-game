{"version":3,"sources":["wordfind.js"],"names":["letters","allOrientations","orientations","checkOrientations","skipOrientations","diagonalBack","placeWord","fillPuzzle","words","options","j","len","i","height","horizontalBack","l","width","puzzle","push","y","length","word","locations","findBestLocations","sel","Math","floor","random","vertical","x","orientation","diagonalUp","exports","window","fillBlanks","verticalUp","h","w","diagonal","diagonalUpBack","horizontal","wordLength","k","nextPossible","next","skipTo","check","maxOverlap","overlap","fnGetSquare","square","preferOverlap","pruneLocations","pruned","validOrientations","newPuzzle","settings","attempts","opts","wordList","slice","sort","a","b","undefined","maxAttempts","this","randomLetter","solve","found","notFound","print","puzzleString","row","console","call"],"mappings":"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","file":"wordfind.js","sourcesContent":["/**\r\n* Wordfind.js 0.0.1\r\n* (c) 2012 Bill, BunKat LLC.\r\n* Wordfind is freely distributable under the MIT license.\r\n* For all details and documentation:\r\n*     http://github.com/bunkat/wordfind\r\n*/\r\n\r\n(function () {\r\n\r\n  'use strict';\r\n\r\n  /**\r\n  * Generates a new word find (word search) puzzle provided a set of words.\r\n  * Can automatically determine the smallest puzzle size in which all words\r\n  * fit, or the puzzle size can be manually configured.  Will automatically\r\n  * increase puzzle size until a valid puzzle is found.\r\n  *\r\n  * WordFind has no dependencies.\r\n  */\r\n\r\n  /**\r\n  * Initializes the WordFind object.\r\n  *\r\n  * @api private\r\n  */\r\n  var WordFind = function () {\r\n\r\n    // Letters used to fill blank spots in the puzzle\r\n    var letters = 'abcdefghijklmnoprstuvwy';\r\n\r\n    /**\r\n    * Definitions for all the different orientations in which words can be\r\n    * placed within a puzzle. New orientation definitions can be added and they\r\n    * will be automatically available.\r\n    */\r\n\r\n    // The list of all the possible orientations\r\n    var allOrientations = ['horizontal','horizontalBack','vertical','verticalUp',\r\n                           'diagonal','diagonalUp','diagonalBack','diagonalUpBack'];\r\n\r\n    // The definition of the orientation, calculates the next square given a\r\n    // starting square (x,y) and distance (i) from that square.\r\n    var orientations = {\r\n      horizontal:     function(x,y,i) { return {x: x+i, y: y  }; },\r\n      horizontalBack: function(x,y,i) { return {x: x-i, y: y  }; },\r\n      vertical:       function(x,y,i) { return {x: x,   y: y+i}; },\r\n      verticalUp:     function(x,y,i) { return {x: x,   y: y-i}; },\r\n      diagonal:       function(x,y,i) { return {x: x+i, y: y+i}; },\r\n      diagonalBack:   function(x,y,i) { return {x: x-i, y: y+i}; },\r\n      diagonalUp:     function(x,y,i) { return {x: x+i, y: y-i}; },\r\n      diagonalUpBack: function(x,y,i) { return {x: x-i, y: y-i}; }\r\n    };\r\n\r\n    // Determines if an orientation is possible given the starting square (x,y),\r\n    // the height (h) and width (w) of the puzzle, and the length of the word (l).\r\n    // Returns true if the word will fit starting at the square provided using\r\n    // the specified orientation.\r\n    var checkOrientations = {\r\n      horizontal:     function(x,y,h,w,l) { return w >= x + l; },\r\n      horizontalBack: function(x,y,h,w,l) { return x + 1 >= l; },\r\n      vertical:       function(x,y,h,w,l) { return h >= y + l; },\r\n      verticalUp:     function(x,y,h,w,l) { return y + 1 >= l; },\r\n      diagonal:       function(x,y,h,w,l) { return (w >= x + l) && (h >= y + l); },\r\n      diagonalBack:   function(x,y,h,w,l) { return (x + 1 >= l) && (h >= y + l); },\r\n      diagonalUp:     function(x,y,h,w,l) { return (w >= x + l) && (y + 1 >= l); },\r\n      diagonalUpBack: function(x,y,h,w,l) { return (x + 1 >= l) && (y + 1 >= l); }\r\n    };\r\n\r\n    // Determines the next possible valid square given the square (x,y) was ]\r\n    // invalid and a word lenght of (l).  This greatly reduces the number of\r\n    // squares that must be checked. Returning {x: x+1, y: y} will always work\r\n    // but will not be optimal.\r\n    var skipOrientations = {\r\n      horizontal:     function(x,y,l) { return {x: 0,   y: y+1  }; },\r\n      horizontalBack: function(x,y,l) { return {x: l-1, y: y    }; },\r\n      vertical:       function(x,y,l) { return {x: 0,   y: y+100}; },\r\n      verticalUp:     function(x,y,l) { return {x: 0,   y: l-1  }; },\r\n      diagonal:       function(x,y,l) { return {x: 0,   y: y+1  }; },\r\n      diagonalBack:   function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y    }; },\r\n      diagonalUp:     function(x,y,l) { return {x: 0,   y: y<l-1?l-1:y+1  }; },\r\n      diagonalUpBack: function(x,y,l) { return {x: l-1, y: x>=l-1?y+1:y  }; }\r\n    };\r\n\r\n    /**\r\n    * Initializes the puzzle and places words in the puzzle one at a time.\r\n    *\r\n    * Returns either a valid puzzle with all of the words or null if a valid\r\n    * puzzle was not found.\r\n    *\r\n    * @param {[String]} words: The list of words to fit into the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    */\r\n    var fillPuzzle = function (words, options) {\r\n\r\n      var puzzle = [], i, j, len;\r\n\r\n      // initialize the puzzle with blanks\r\n      for (i = 0; i < options.height; i++) {\r\n        puzzle.push([]);\r\n        for (j = 0; j < options.width; j++) {\r\n          puzzle[i].push('');\r\n        }\r\n      }\r\n\r\n      // add each word into the puzzle one at a time\r\n      for (i = 0, len = words.length; i < len; i++) {\r\n        if (!placeWordInPuzzle(puzzle, options, words[i])) {\r\n          // if a word didn't fit in the puzzle, give up\r\n          return null;\r\n        }\r\n      }\r\n\r\n      // return the puzzle\r\n      return puzzle;\r\n    };\r\n\r\n    /**\r\n    * Adds the specified word to the puzzle by finding all of the possible\r\n    * locations where the word will fit and then randomly selecting one. Options\r\n    * controls whether or not word overlap should be maximized.\r\n    *\r\n    * Returns true if the word was successfully placed, false otherwise.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    */\r\n    var placeWordInPuzzle = function (puzzle, options, word) {\r\n\r\n      // find all of the best locations where this word would fit\r\n      var locations = findBestLocations(puzzle, options, word);\r\n\r\n      if (locations.length === 0) {\r\n        return false;\r\n      }\r\n\r\n      // select a location at random and place the word there\r\n      var sel = locations[Math.floor(Math.random() * locations.length)];\r\n      placeWord(puzzle, word, sel.x, sel.y, orientations[sel.orientation]);\r\n\r\n      return true;\r\n    };\r\n\r\n    /**\r\n    * Iterates through the puzzle and determines all of the locations where\r\n    * the word will fit. Options determines if overlap should be maximized or\r\n    * not.\r\n    *\r\n    * Returns a list of location objects which contain an x,y cooridinate\r\n    * indicating the start of the word, the orientation of the word, and the\r\n    * number of letters that overlapped with existing letter.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {[Options]} options: The options to use when filling the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    */\r\n    var findBestLocations = function (puzzle, options, word) {\r\n\r\n      var locations = [],\r\n          height = options.height,\r\n          width = options.width,\r\n          wordLength = word.length,\r\n          maxOverlap = 0; // we'll start looking at overlap = 0\r\n\r\n      // loop through all of the possible orientations at this position\r\n      for (var k = 0, len = options.orientations.length; k < len; k++) {\r\n        \r\n        var orientation = options.orientations[k],\r\n            check = checkOrientations[orientation],\r\n            next = orientations[orientation],\r\n            skipTo = skipOrientations[orientation],\r\n            x = 0, y = 0;\r\n\r\n        // loop through every position on the board\r\n        while( y < height ) {\r\n\r\n          // see if this orientation is even possible at this location\r\n          if (check(x, y, height, width, wordLength)) {\r\n\r\n            // determine if the word fits at the current position\r\n            var overlap = calcOverlap(word, puzzle, x, y, next);\r\n\r\n            // if the overlap was bigger than previous overlaps that we've seen\r\n            if (overlap >= maxOverlap || (!options.preferOverlap && overlap > -1)) {\r\n              maxOverlap = overlap;\r\n              locations.push({x: x, y: y, orientation: orientation, overlap: overlap});\r\n            }\r\n\r\n            x++;\r\n            if (x >= width) {\r\n              x = 0;\r\n              y++;\r\n            }\r\n          }\r\n          else {\r\n            // if current cell is invalid, then skip to the next cell where\r\n            // this orientation is possible. this greatly reduces the number\r\n            // of checks that we have to do overall\r\n            var nextPossible = skipTo(x,y,wordLength);\r\n            x = nextPossible.x;\r\n            y = nextPossible.y;\r\n          }\r\n\r\n        }\r\n      }\r\n\r\n      // finally prune down all of the possible locations we found by\r\n      // only using the ones with the maximum overlap that we calculated\r\n      return options.preferOverlap ?\r\n             pruneLocations(locations, maxOverlap) :\r\n             locations;\r\n    };\r\n\r\n    /**\r\n    * Determines whether or not a particular word fits in a particular\r\n    * orientation within the puzzle.\r\n    *\r\n    * Returns the number of letters overlapped with existing words if the word\r\n    * fits in the specified position, -1 if the word does not fit.\r\n    *\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {int} x: The x position to check\r\n    * @param {int} y: The y position to check\r\n    * @param {function} fnGetSquare: Function that returns the next square\r\n    */\r\n    var calcOverlap = function (word, puzzle, x, y, fnGetSquare) {\r\n      var overlap = 0;\r\n\r\n      // traverse the squares to determine if the word fits\r\n      for (var i = 0, len = word.length; i < len; i++) {\r\n\r\n        var next = fnGetSquare(x, y, i),\r\n            square = puzzle[next.y][next.x];\r\n        \r\n        // if the puzzle square already contains the letter we\r\n        // are looking for, then count it as an overlap square\r\n        if (square === word[i]) {\r\n          overlap++;\r\n        }\r\n        // if it contains a different letter, than our word doesn't fit\r\n        // here, return -1\r\n        else if (square !== '' ) {\r\n          return -1;\r\n        }\r\n      }\r\n\r\n      // if the entire word is overlapping, skip it to ensure words aren't\r\n      // hidden in other words\r\n      return overlap;\r\n    };\r\n\r\n    /**\r\n    * If overlap maximization was indicated, this function is used to prune the\r\n    * list of valid locations down to the ones that contain the maximum overlap\r\n    * that was previously calculated.\r\n    *\r\n    * Returns the pruned set of locations.\r\n    *\r\n    * @param {[Location]} locations: The set of locations to prune\r\n    * @param {int} overlap: The required level of overlap\r\n    */\r\n    var pruneLocations = function (locations, overlap) {\r\n\r\n      var pruned = [];\r\n      for(var i = 0, len = locations.length; i < len; i++) {\r\n        if (locations[i].overlap >= overlap) {\r\n          pruned.push(locations[i]);\r\n        }\r\n      }\r\n\r\n      return pruned;\r\n    };\r\n\r\n    /**\r\n    * Places a word in the puzzle given a starting position and orientation.\r\n    *\r\n    * @param {[[String]]} puzzle: The current state of the puzzle\r\n    * @param {String} word: The word to fit into the puzzle.\r\n    * @param {int} x: The x position to check\r\n    * @param {int} y: The y position to check\r\n    * @param {function} fnGetSquare: Function that returns the next square\r\n    */\r\n    var placeWord = function (puzzle, word, x, y, fnGetSquare) {\r\n      for (var i = 0, len = word.length; i < len; i++) {\r\n        var next = fnGetSquare(x, y, i);\r\n        puzzle[next.y][next.x] = word[i];\r\n      }\r\n    };\r\n\r\n    return {\r\n\r\n      /**\r\n      * Returns the list of all of the possible orientations.\r\n      * @api public\r\n      */\r\n      validOrientations: allOrientations,\r\n\r\n      /**\r\n      * Returns the orientation functions for traversing words.\r\n      * @api public\r\n      */\r\n      orientations: orientations,\r\n\r\n      /**\r\n      * Generates a new word find (word search) puzzle.\r\n      *\r\n      * Settings:\r\n      *\r\n      * height: desired height of the puzzle, default: smallest possible\r\n      * width:  desired width of the puzzle, default: smallest possible\r\n      * orientations: list of orientations to use, default: all orientations\r\n      * fillBlanks: true to fill in the blanks, default: true\r\n      * maxAttempts: number of tries before increasing puzzle size, default:3\r\n      * preferOverlap: maximize word overlap or not, default: true\r\n      *\r\n      * Returns the puzzle that was created.\r\n      *\r\n      * @param {[String]} words: List of words to include in the puzzle\r\n      * @param {options} settings: The options to use for this puzzle\r\n      * @api public\r\n      */\r\n      newPuzzle: function(words, settings) {\r\n        var wordList, puzzle, attempts = 0, opts = settings || {};\r\n\r\n        // copy and sort the words by length, inserting words into the puzzle\r\n        // from longest to shortest works out the best\r\n        wordList = words.slice(0).sort( function (a,b) {\r\n          return (a.length < b.length) ? 1 : 0;\r\n        });\r\n        \r\n        // initialize the options\r\n        var options = {\r\n          height:       opts.height || wordList[0].length,\r\n          width:        opts.width || wordList[0].length,\r\n          orientations: opts.orientations || allOrientations,\r\n          fillBlanks:   opts.fillBlanks !== undefined ? opts.fillBlanks : true,\r\n          maxAttempts:  opts.maxAttempts || 3,\r\n          preferOverlap: opts.preferOverlap !== undefined ? opts.preferOverlap : true\r\n        };\r\n\r\n        // add the words to the puzzle\r\n        // since puzzles are random, attempt to create a valid one up to\r\n        // maxAttempts and then increase the puzzle size and try again\r\n        while (!puzzle) {\r\n          while (!puzzle && attempts++ < options.maxAttempts) {\r\n            puzzle = fillPuzzle(wordList, options);\r\n          }\r\n\r\n          if (!puzzle) {\r\n            options.height++;\r\n            options.width++;\r\n            attempts = 0;\r\n          }\r\n        }\r\n\r\n        // fill in empty spaces with random letters\r\n        if (options.fillBlanks) {\r\n          this.fillBlanks(puzzle, options);\r\n        }\r\n\r\n        return puzzle;\r\n      },\r\n\r\n      /**\r\n      * Fills in any empty spaces in the puzzle with random letters.\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @api public\r\n      */\r\n      fillBlanks: function (puzzle) {\r\n        for (var i = 0, height = puzzle.length; i < height; i++) {\r\n          var row = puzzle[i];\r\n          for (var j = 0, width = row.length; j < width; j++) {\r\n\r\n            if (!puzzle[i][j]) {\r\n              var randomLetter = Math.floor(Math.random() * letters.length);\r\n              puzzle[i][j] = letters[randomLetter];\r\n            }\r\n          }\r\n        }\r\n      },\r\n\r\n      /**\r\n      * Returns the starting location and orientation of the specified words\r\n      * within the puzzle. Any words that are not found are returned in the\r\n      * notFound array.\r\n      *\r\n      * Returns\r\n      *   x position of start of word\r\n      *   y position of start of word\r\n      *   orientation of word\r\n      *   word\r\n      *   overlap (always equal to word.length)\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @param {[String]} words: The list of words to find\r\n      * @api public\r\n      */\r\n      solve: function (puzzle, words) {\r\n        var options = {\r\n                        height:       puzzle.length,\r\n                        width:        puzzle[0].length,\r\n                        orientations: allOrientations,\r\n                        preferOverlap: true\r\n                      },\r\n            found = [],\r\n            notFound = [];\r\n\r\n        for(var i = 0, len = words.length; i < len; i++) {\r\n          var word = words[i],\r\n              locations = findBestLocations(puzzle, options, word);\r\n\r\n          if (locations.length > 0 && locations[0].overlap === word.length) {\r\n            locations[0].word = word;\r\n            found.push(locations[0]);\r\n          }\r\n          else {\r\n            notFound.push(word);\r\n          }\r\n        }\r\n\r\n        return { found: found, notFound: notFound };\r\n      },\r\n\r\n      /**\r\n      * Outputs a puzzle to the console, useful for debugging.\r\n      * Returns a formatted string representing the puzzle.\r\n      *\r\n      * @param {[[String]]} puzzle: The current state of the puzzle\r\n      * @api public\r\n      */\r\n      print: function (puzzle) {\r\n        var puzzleString = '';\r\n        for (var i = 0, height = puzzle.length; i < height; i++) {\r\n          var row = puzzle[i];\r\n          for (var j = 0, width = row.length; j < width; j++) {\r\n            puzzleString += (row[j] === '' ? ' ' : row[j]) + ' ';\r\n          }\r\n          puzzleString += '\\n';\r\n        }\r\n\r\n        console.log(puzzleString);\r\n        return puzzleString;\r\n      }\r\n    };\r\n  };\r\n\r\n  /**\r\n  * Allow library to be used within both the browser and node.js\r\n  */\r\n  var root = typeof exports !== \"undefined\" && exports !== null ? exports : window;\r\n  root.wordfind = WordFind();\r\n\r\n}).call(this);\r\n\r\n\r\n\r\n"]}